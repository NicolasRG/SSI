{"version":3,"sources":["imgs/f-texture.png","components/AnimatedBackground.js","BackgroundScript/shaderLoader.js","BackgroundScript/initBuffersCube.js","BackgroundScript/drawHelperFunctions.js","BackgroundScript/vertexShader.js","BackgroundScript/fragShader.js","components/App.js","serviceWorker.js","index.js"],"names":["module","exports","__webpack_require__","p","texture","loadShader","gl","type","source","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","alert","getShaderInfoLog","deleteShader","initCubeBuffers","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","indexBuffer","ELEMENT_ARRAY_BUFFER","Uint16Array","faceColors","colors","j","length","c","concat","colorBuffer","texcoords","position","indices","color","texbuffer","translate","axisRotate","glm","require","then","cubeRotation","objects","AnimatedBackground","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","height","window","innerHeight","width","innerWidth","getComputedStyle","bind","assertThisInitialized","renderBackground","_this2","addEventListener","canvas","document","getElementById","getContext","shaderProgram","vsSource","fsSource","vertexShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","initShaderProgram","createTexture","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","Uint8Array","image","Image","src","console","log","generateMipmap","programInfo","program","attribLocations","vertexPosition","getAttribLocation","vertexColor","texcoordLocation","uniformLocations","projectionMatrix","getUniformLocation","textureLocation","push","requestAnimationFrame","now","delta","drawScene","clientHeight","clientWidth","setState","viewport","react_default","a","createElement","id","Component","clearColor","clearDepth","enable","DEPTH_TEST","depthFunc","LEQUAL","CULL_FACE","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","fieldOfView","Math","PI","aspect","mat4","create","perspective","cameraPosition","cos","sin","cameraMatrix","targetTo","viewProjectionMatrix","viewMatrix","invert","multiply","createViewProjectionMatrix","useProgram","forEach","d","i","xPos","pow","modelViewMatrix","u_worldViewProjection","object","FLOAT","vertexAttribPointer","enableVertexAttribArray","uniformMatrix4fv","setUniforms","UNSIGNED_SHORT","uniform1i","drawElements","TRIANGLES","socket","openSocket","App","emit","className","components_AnimatedBackground","Boolean","location","hostname","match","ReactDOM","render","components_App","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.cee4597b.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/f-texture.89efad94.png\";","import React, {Component} from 'react';\r\nimport {initShaderProgram} from  '../BackgroundScript/shaderLoader.js';\r\nimport {fsSource} from '../BackgroundScript/fragShader.js';\r\nimport {vsSource} from '../BackgroundScript/vertexShader.js';\r\nimport {initCubeBuffers} from '../BackgroundScript/initBuffersCube.js';\r\nimport {setUniforms, createViewProjectionMatrix} from '../BackgroundScript/drawHelperFunctions.js';\r\nimport '../stylesheets/AnimatedBackground.css';\r\nimport img from  '../imgs/f-texture.png';\r\nconst glm = require('gl-matrix');\r\n\r\nlet then = 0;\r\nlet cubeRotation = .1;\r\nlet objects = [];\r\nlet texture;\r\n  \r\nclass AnimatedBackground extends Component{\r\n    constructor(props){\r\n        super(props);\r\n        this.state ={\r\n            height:window.innerHeight,\r\n            width:window.innerWidth,\r\n        }\r\n\r\n        this.getComputedStyle = this.getComputedStyle.bind(this);\r\n        this.renderBackground = this.renderBackground.bind(this);\r\n    }\r\n\r\n\r\n\r\n    componentDidMount(){\r\n        //Set width/height correctly first\r\n        //this.getComputedStyle();\r\n        window.addEventListener(\"resize\", this.getComputedStyle);\r\n        //render WebGl\r\n        this.canvas = document.getElementById(\"animatedBackground\");\r\n        this.gl =  this.canvas.getContext(\"webgl\");\r\n\r\n        if( this.gl === null){\r\n            alert(\"Unable to initialize WebGL. Your browser or machine may not support it.\");\r\n            return;\r\n        }\r\n\r\n\r\n        const shaderProgram = initShaderProgram(this.gl, vsSource, fsSource);\r\n\r\n        texture = this.gl.createTexture();\r\n        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);\r\n        // Fill the texture with a 1x1 blue pixel.\r\n        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE,\r\n                      new Uint8Array([0, 255, 0, 255]));\r\n\r\n        var image = new Image();\r\n        image.src = \"https://webglfundamentals.org/webgl/resources/f-texture.png\";\r\n        console.log(image);\r\n\r\n        //image.src = img;\r\n        image.addEventListener('load', ()=>{\r\n        this.gl.bindTexture( this.gl.TEXTURE_2D, texture);\r\n        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.RGBA, this.gl.UNSIGNED_BYTE, image);\r\n        this.gl.generateMipmap(this.gl.TEXTURE_2D);\r\n        });\r\n\r\n        this.programInfo ={\r\n            program: shaderProgram,\r\n            attribLocations: {\r\n              vertexPosition: this.gl.getAttribLocation(shaderProgram, 'aVertexPosition'),\r\n              vertexColor: this.gl.getAttribLocation(shaderProgram, 'aVertexColor'),\r\n              texcoordLocation : this.gl.getAttribLocation(shaderProgram, 'a_texCoord')\r\n            },\r\n            uniformLocations: {\r\n              projectionMatrix: this.gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),\r\n              textureLocation : this.gl.getUniformLocation(shaderProgram, 'u_texture'),\r\n            }, \r\n        }\r\n\r\n        objects.push(initCubeBuffers(this.gl));\r\n        objects.push(initCubeBuffers(this.gl));\r\n        objects.push(initCubeBuffers(this.gl));\r\n        objects.push(initCubeBuffers(this.gl));\r\n        objects.push(initCubeBuffers(this.gl));\r\n        objects.push(initCubeBuffers(this.gl));\r\n        objects.push(initCubeBuffers(this.gl));\r\n        requestAnimationFrame(this.renderBackground);\r\n\r\n    }\r\n\r\n    renderBackground(now){\r\n        now *= 0.001;  // convert to seconds\r\n        const delta = now - then;\r\n        then = now;\r\n    \r\n        drawScene(this.gl, this.programInfo, delta);\r\n        //this.gl.viewport(0,0, this.gl.canvas.width, this.gl.canvas.height);\r\n        requestAnimationFrame(this.renderBackground);\r\n      }\r\n\r\n    getComputedStyle(){\r\n        const  height = this.canvas.clientHeight;\r\n        const width = this.canvas.clientWidth;\r\n        this.setState({\r\n            \"height\" : height+\"px\",\r\n            \"width\" : width+\"px\",\r\n        });\r\n        this.canvas.height = this.gl.canvas.height;\r\n        this.canvas.width = this.gl.canvas.width;\r\n        this.gl.viewport(0,0, this.gl.canvas.width, this.gl.canvas.height);\r\n        console.log(this.gl.canvas.width);\r\n    }\r\n\r\n    render(){return <canvas id = \"animatedBackground\"\r\n                    width = {this.state[\"width\"]}\r\n                    height = {this.state[\"height\"]}\r\n             >\r\n                error\r\n        </canvas>\r\n    }\r\n}\r\n\r\n\r\n\r\nexport default AnimatedBackground;\r\n\r\nconst drawScene=(gl, programInfo, delta)=>{\r\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque\r\n    gl.clearDepth(1.0);                 // Clear everything\r\n    gl.enable(gl.DEPTH_TEST);           // Enable depth testing\r\n    gl.depthFunc(gl.LEQUAL);            // Near things obscure far things\r\n    gl.enable(gl.CULL_FACE);\r\n    \r\n    // Clear the canvas before we start drawing on it.\r\n  \r\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n  \r\n    // Create a perspective matrix, a special matrix that is\r\n    // used to simulate the distortion of perspective in a camera.\r\n    // Our field of view is 45 degrees, with a width/height\r\n    // ratio that matches the display size of the canvas\r\n    // and we only want to see objects between 0.1 units\r\n    // and 100 units away from the camera.\r\n  \r\n    const fieldOfView = 45 * Math.PI / 180;   // in radians\r\n    const aspect = gl.canvas.width / gl.canvas.height;\r\n    const zNear = 0.1;\r\n    const zFar = 100.0;\r\n    const projectionMatrix = glm.mat4.create();\r\n    // note: glmatrix.js always has the first argument\r\n    // as the destination to receive the result.\r\n    glm.mat4.perspective(projectionMatrix,\r\n                     fieldOfView,\r\n                     aspect,\r\n                     zNear,\r\n                     zFar);\r\n     // Tell WebGL to use our program when drawing\r\n     //and where to look at   \r\n     var cameraPosition = [(20 * Math.cos(cubeRotation)), 0, (20 * Math.sin(cubeRotation))];\r\n     var target = [0, 0, 0];\r\n     var up = [0, 1, 0];\r\n     var cameraMatrix = glm.mat4.create();\r\n     \r\n     glm.mat4.targetTo(cameraMatrix, cameraPosition, target, up);\r\n     //glm.mat4.rotate(projectionMatrix, projectionMatrix, cubeRotation/2, [0,0,0 ]);\r\n\r\n     // Make a view matrix from the camera matrix.\r\n    var viewProjectionMatrix= createViewProjectionMatrix(projectionMatrix, cameraMatrix);\r\n\r\n    gl.useProgram(programInfo.program);\r\n   \r\n   \r\n\r\n    const downDelta =  -.25*((cubeRotation) % 10);\r\n    //create three different squares that rotate \r\n    objects.forEach((d,i)=>{\r\n                //----------------- Where Object Personal Properties are at -------------------------------------------\r\n                const xPos = -8.0 + (3*i);\r\n                const down = downDelta + ((i - 3)**2)+10;        \r\n                d.translate = [xPos, 0.0, -0.0];\r\n                d.axisRotate =[0,0,0];\r\n                d.axisRotate[i] = 1;\r\n        \r\n                // Set the drawing position to the \"identity\" point, which is\r\n                // the center of the scene.\r\n                const modelViewMatrix = glm.mat4.create();\r\n               \r\n                // Now move the drawing position a bit to where we want to\r\n                // start drawing the square.\r\n            \r\n                glm.mat4.translate(modelViewMatrix,     // destination matrix\r\n                            modelViewMatrix,     // matrix to translate\r\n                            d.translate);  // amount to translate\r\n        \r\n                /*glm.mat4.rotate(modelViewMatrix,  // destination matrix\r\n                            modelViewMatrix,  // matrix to rotate\r\n                        cubeRotation,   // amount to rotate in radian\r\n                        d.axisRotate);       // axis to rotate around */\r\n                     \r\n                \r\n                var u_worldViewProjection = glm.mat4.create();\r\n                glm.mat4.multiply(u_worldViewProjection, viewProjectionMatrix, modelViewMatrix);                 \r\n                d.u_worldViewProjection = u_worldViewProjection; \r\n                \r\n                setUniforms(gl, programInfo, d);\r\n        \r\n                {\r\n                const vertexCount = 36;\r\n                const type = gl.UNSIGNED_SHORT;\r\n                const offset = 0;\r\n\r\n                // Tell the shader to use texture unit 0 for u_texture\r\n                gl.uniform1i(programInfo.uniformLocations.textureLocation, 0);\r\n                gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);\r\n                }\r\n    });\r\n    cubeRotation = delta + cubeRotation;\r\n}\r\n\r\n","const initShaderProgram=(gl, vsSource, fsSource)=>{\r\n    const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);\r\n    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);\r\n  \r\n    // Create the shader program\r\n  \r\n    const shaderProgram = gl.createProgram();\r\n    gl.attachShader(shaderProgram, vertexShader);\r\n    gl.attachShader(shaderProgram, fragmentShader);\r\n    gl.linkProgram(shaderProgram);\r\n  \r\n    // If creating the shader program failed, alert\r\n  \r\n    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\r\n      alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));\r\n      return null;\r\n    }\r\n  \r\n    return shaderProgram;\r\n}\r\n\r\nconst loadShader=(gl,type, source)=>{\r\n    const shader = gl.createShader(type);\r\n\r\n    // Send the source to the shader object\r\n  \r\n    gl.shaderSource(shader, source);\r\n  \r\n    // Compile the shader program\r\n  \r\n    gl.compileShader(shader);\r\n  \r\n    // See if it compiled successfully\r\n  \r\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n      alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));\r\n      gl.deleteShader(shader);\r\n      return null;\r\n    }\r\n  \r\n    return shader;\r\n}\r\n\r\nexport {loadShader,\r\n        initShaderProgram}\r\n\r\n","\r\nconst initCubeBuffers=(gl)=>{\r\n    // Create a buffer for the square's positions.\r\n\r\n  const positionBuffer = gl.createBuffer();\r\n\r\n  // Select the positionBuffer as the one to apply buffer\r\n  // operations to from here out.\r\n\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\r\n\r\n  // Now create an array of positions for the square.\r\n\r\n  const positions = [\r\n    // Front face\r\n    -1.0, -1.0,  1.0,\r\n     1.0, -1.0,  1.0,\r\n     1.0,  1.0,  1.0,\r\n    -1.0,  1.0,  1.0,\r\n    \r\n    // Back face\r\n    -1.0, -1.0, -1.0,\r\n    -1.0,  1.0, -1.0,\r\n     1.0,  1.0, -1.0,\r\n     1.0, -1.0, -1.0,\r\n    \r\n    // Top face\r\n    -1.0,  1.0, -1.0,\r\n    -1.0,  1.0,  1.0,\r\n     1.0,  1.0,  1.0,\r\n     1.0,  1.0, -1.0,\r\n    \r\n    // Bottom face\r\n    -1.0, -1.0, -1.0,\r\n     1.0, -1.0, -1.0,\r\n     1.0, -1.0,  1.0,\r\n    -1.0, -1.0,  1.0,\r\n    \r\n    // Right face\r\n     1.0, -1.0, -1.0,\r\n     1.0,  1.0, -1.0,\r\n     1.0,  1.0,  1.0,\r\n     1.0, -1.0,  1.0,\r\n    \r\n    // Left face\r\n    -1.0, -1.0, -1.0,\r\n    -1.0, -1.0,  1.0,\r\n    -1.0,  1.0,  1.0,\r\n    -1.0,  1.0, -1.0,\r\n  ];\r\n\r\n\r\n\r\n  // Now pass the list of positions into WebGL to build the\r\n  // shape. We do this by creating a Float32Array from the\r\n  // JavaScript array, then use it to fill the current buffer.\r\n\r\n  gl.bufferData(gl.ARRAY_BUFFER,\r\n                new Float32Array(positions),\r\n                gl.STATIC_DRAW);\r\n\r\n   // Build the element array buffer; this specifies the indices\r\n  // into the vertex arrays for each face's vertices.\r\n\r\n  const indexBuffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n\r\n  // This array defines each face as two triangles, using the\r\n  // indices into the vertex array to specify each triangle's\r\n  // position.\r\n\r\n  const indices = [\r\n    0,  1,  2,      0,  2,  3,    // front\r\n    4,  5,  6,      4,  6,  7,    // back\r\n    8,  9,  10,     8,  10, 11,   // top\r\n    12, 13, 14,     12, 14, 15,   // bottom\r\n    16, 17, 18,     16, 18, 19,   // right\r\n    20, 21, 22,     20, 22, 23,   // left\r\n  ];\r\n\r\n  // Now send the element array to GL\r\n\r\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,\r\n      new Uint16Array(indices), gl.STATIC_DRAW);\r\n\r\n  const faceColors = [\r\n        [1.0,  1.0,  1.0,  1.0],    // Front face: white\r\n        [1.0,  0.0,  0.0,  1.0],    // Back face: red\r\n        [0.0,  1.0,  0.0,  1.0],    // Top face: green\r\n        [0.0,  0.0,  1.0,  1.0],    // Bottom face: blue\r\n        [1.0,  1.0,  0.0,  1.0],    // Right face: yellow\r\n        [1.0,  0.0,  1.0,  1.0],    // Left face: purple\r\n  ];\r\n    \r\n  // Convert the array of colors into a table for all the vertices.\r\n    \r\n  var colors = [];\r\n    \r\n  for (var j = 0; j < faceColors.length; ++j) {\r\n    const c = faceColors[j];\r\n    \r\n    // Repeat each color four times for the four vertices of the face\r\n    colors = colors.concat(c, c, c, c);\r\n  }\r\n    \r\n  const colorBuffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\r\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW); \r\n  \r\n  //create  buffer for texcoords.\r\n  const coordst = [\r\n    // left column front\r\n    0, 0,\r\n    0, 1,\r\n    1, 0,\r\n    0, 1,\r\n    1, 1,\r\n    1, 0,\r\n     // left column front\r\n     0, 0,\r\n     0, 1,\r\n     1, 0,\r\n     0, 1,\r\n     1, 1,\r\n     1, 0,\r\n      // left column front\r\n    0, 0,\r\n    0, 1,\r\n    1, 0,\r\n    0, 1,\r\n    1, 1,\r\n    1, 0,\r\n     // left column front\r\n     0, 0,\r\n     0, 1,\r\n     1, 0,\r\n     0, 1,\r\n     1, 1,\r\n     1, 0,\r\n      // left column front\r\n    0, 0,\r\n    0, 1,\r\n    1, 0,\r\n    0, 1,\r\n    1, 1,\r\n    1, 0,\r\n     // left column front\r\n     0, 0,\r\n     0, 1,\r\n     1, 0,\r\n     0, 1,\r\n     1, 1,\r\n     1, 0,];\r\n\r\n     let texcoords = gl.createBuffer();\r\n     gl.bindBuffer(gl.ARRAY_BUFFER, texcoords);\r\n     gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(coordst), gl.STATIC_DRAW);\r\n\r\n    return {\r\n        position: positionBuffer,\r\n        indices: indexBuffer,\r\n        color: colorBuffer,\r\n        texbuffer : texcoords,\r\n        translate : [-0.0, 0.0, -0.0],\r\n        axisRotate : [0, 0, 0],\r\n    };\r\n}\r\n\r\n\r\n\r\nexport {initCubeBuffers}","\r\nconst glm = require('gl-matrix');\r\n\r\nconst setUniforms=(gl, programInfo, object)=>{\r\n        {const numComponents = 3;  // pull out 2 values per iteration\r\n        const type = gl.FLOAT;    // the data in the buffer is 32bit floats\r\n        const normalize = false;  // don't normalize\r\n        const stride = 0;         // how many bytes to get from one set of values to the next\r\n                                    // 0 = use type and numComponents above\r\n        const offset = 0;         // how many bytes inside the buffer to start from\r\n        \r\n        gl.bindBuffer(gl.ARRAY_BUFFER, object.position);\r\n        gl.vertexAttribPointer(\r\n            programInfo.attribLocations.vertexPosition,\r\n            numComponents,\r\n            type,\r\n            normalize,\r\n            stride,\r\n            offset);\r\n        \r\n            gl.enableVertexAttribArray(\r\n            programInfo.attribLocations.vertexPosition);\r\n        }\r\n\r\n        // Tell WebGL how to pull out the colors from the color buffer\r\n        // into the vertexColor attribute.\r\n        {\r\n            const numComponents = 4;\r\n            const type = gl.FLOAT;\r\n            const normalize = false;\r\n            const stride = 0;\r\n            const offset = 0;\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, object.color);\r\n            gl.vertexAttribPointer(\r\n                programInfo.attribLocations.vertexColor,\r\n                numComponents,\r\n                type,\r\n                normalize,\r\n                stride,\r\n                offset);\r\n            gl.enableVertexAttribArray(\r\n                programInfo.attribLocations.vertexColor);\r\n        };\r\n\r\n         // Turn on the teccord attribute\r\n        gl.enableVertexAttribArray(programInfo.attribLocations.texcoordLocation);\r\n\r\n        // Bind the position buffer.\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, object.texbuffer);\r\n\r\n        // Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)\r\n        var size = 2;          // 2 components per iteration\r\n        var type = gl.FLOAT;   // the data is 32bit floats\r\n        var normalize = false; // don't normalize the data\r\n        var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position\r\n        var offset = 0;        // start at the beginning of the buffer\r\n        gl.vertexAttribPointer(\r\n            programInfo.attribLocations.texcoordLocation, size, type, normalize, stride, offset);\r\n\r\n       // Set the shader uniforms\r\n       gl.uniformMatrix4fv(\r\n        programInfo.uniformLocations.projectionMatrix,\r\n        false,\r\n        object.u_worldViewProjection);\r\n\r\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, object.indices);    \r\n}\r\n\r\nconst createViewProjectionMatrix =(projectionMatrix, cameraMatrix)=>{\r\n    // Make a view matrix from the camera matrix.\r\n     var viewMatrix = glm.mat4.create();\r\n    glm.mat4.invert(viewMatrix, cameraMatrix);\r\n\r\n    var viewProjectionMatrix = glm.mat4.create();\r\n    glm.mat4.multiply( viewProjectionMatrix , projectionMatrix, viewMatrix);\r\n\r\n    return viewProjectionMatrix;\r\n}\r\n\r\n\r\n\r\n\r\nexport {setUniforms, createViewProjectionMatrix}","export const vsSource = `\r\n    attribute vec4 aVertexPosition;\r\n    attribute vec4 aVertexColor;\r\n    attribute vec2 a_texCoord;\r\n\r\n    uniform mat4 uProjectionMatrix;\r\n\r\n    varying vec4 vColor;\r\n    varying vec4 vPlace;\r\n    varying vec2 v_texCoord;\r\n    \r\n    void main(void) {\r\n        gl_Position = uProjectionMatrix * aVertexPosition;\r\n        vColor = aVertexColor;\r\n        vPlace = aVertexPosition;\r\n\r\n        v_texCoord = a_texCoord;\r\n    }\r\n    `;\r\n\r\n"," export const fsSource = `\r\n precision mediump float;\r\n\r\n varying vec4 vPlace;\r\n varying vec4 vColor;\r\n varying vec2 v_texCoord;\r\n\r\n vec4 final_color;\r\n\r\n uniform sampler2D u_texture;\r\n\r\n\r\n void main(void) { \r\n    float x = pow(vPlace.x,2.0);\r\n    float y = pow((vPlace.y+1.0),2.0);\r\n    float opacity = exp( -1.0*(x+y));\r\n    //opacity = abs(opacity - 1.0);\r\n    //final_color = vColor ;//* opacity;\r\n    //gl_FragColor = final_color ;//vec4(vColor.x, vColor.y, vColor.z, 1);\r\n    gl_FragColor = texture2D(u_texture, v_texCoord);\r\n   }\r\n`;","import React, { Component } from 'react';\r\nimport '../stylesheets/App.css';\r\nimport openSocket from 'socket.io-client';\r\n//import different react components\r\n//import Container from './Container.js'\r\nimport AnimatedBackground from './AnimatedBackground.js';\r\n\r\n//socket.io client\r\nconst socket = openSocket( \"http://192.168.1.8:80\");\r\nclass App extends Component {\r\n  constructor(props){\r\n    super(props);\r\n    this.state = {\r\n      socket:socket,\r\n    }\r\n  }\r\n\r\n  componentDidMount(){\r\n    socket.emit(\"hello\");\r\n  }\r\n\r\n\r\n  render() {\r\n    return (\r\n       \r\n        <div className=\"App\">\r\n          <AnimatedBackground>\r\n            </AnimatedBackground>\r\n          {/*<Container socket = {this.state.socket}/>*/}\r\n        </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './stylesheets/index.css';\nimport App from './components/App.js';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}